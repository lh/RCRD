{"ast":null,"code":"class ClockHourNotation {\n  /**\n   * Check if any segments touch a given hour\n   * @param {number[]} segments - Array of segment numbers\n   * @param {number} hour - Clock hour to check\n   * @returns {boolean}\n   */\n  static segmentsTouchHour(segments, hour) {\n    // Define segment ranges for each hour\n    const hourRanges = {\n      1: [0, 4],\n      // Hour 1: 0-4\n      2: [5, 9],\n      // Hour 2: 5-9\n      3: [10, 14],\n      // Hour 3: 10-14\n      4: [15, 19],\n      // Hour 4: 15-19\n      5: [20, 24],\n      // Hour 5: 20-24\n      6: [25, 29],\n      // Hour 6: 25-29\n      7: [30, 34],\n      // Hour 7: 30-34\n      8: [35, 39],\n      // Hour 8: 35-39\n      9: [40, 44],\n      // Hour 9: 40-44\n      10: [45, 49],\n      // Hour 10: 45-49\n      11: [50, 54],\n      // Hour 11: 50-54\n      12: [55, 59] // Hour 12: 55-59\n    };\n    if (hour === 12) {\n      return segments.some(s => s >= 55 || s <= 4);\n    }\n    const [start, end] = hourRanges[hour];\n    return segments.some(s => s >= start && s <= end);\n  }\n\n  /**\n   * Build ranges from hours with special midnight handling\n   * @param {Set<number>} hours \n   * @returns {Array<{start: number, end: number}>}\n   */\n  static buildRanges(hours) {\n    const hourList = Array.from(hours);\n\n    // First, check for midnight crossing pattern\n    if (hours.has(11) || hours.has(12) || hours.has(1)) {\n      const hasMidnightCrossing = hours.has(11) && hours.has(1) || hours.has(11) && hours.has(12) || hours.has(12) && hours.has(1);\n      if (hasMidnightCrossing) {\n        // Force inclusion of all midnight hours if any are present\n        if (hours.has(11) || hours.has(1)) {\n          hours.add(11);\n          hours.add(12);\n          hours.add(1);\n        }\n\n        // Sort with midnight crossing logic\n        hourList.sort((a, b) => {\n          // Special sorting for midnight hours\n          if ([11, 12, 1].includes(a) && [11, 12, 1].includes(b)) {\n            const order = {\n              11: 1,\n              12: 2,\n              1: 3\n            };\n            return order[a] - order[b];\n          }\n          // Put midnight crossing range first\n          if ([11, 12, 1].includes(a)) return -1;\n          if ([11, 12, 1].includes(b)) return 1;\n          return a - b;\n        });\n      }\n    } else {\n      // Simple numerical sort for non-midnight crossing ranges\n      hourList.sort((a, b) => a - b);\n    }\n\n    // Build ranges\n    const ranges = [];\n    let currentRange = {\n      start: hourList[0],\n      end: hourList[0]\n    };\n    for (let i = 1; i < hourList.length; i++) {\n      const hour = hourList[i];\n      const prevHour = currentRange.end;\n      const isConsecutive = hour === prevHour + 1 || prevHour === 12 && hour === 1 || prevHour === 11 && hour === 12;\n      if (isConsecutive) {\n        currentRange.end = hour;\n      } else {\n        ranges.push(currentRange);\n        currentRange = {\n          start: hour,\n          end: hour\n        };\n      }\n    }\n    ranges.push(currentRange);\n    return ranges;\n  }\n\n  /**\n   * Format clock hour notation for retinal detachment\n   * @param {number[]} segments - Array of affected segments\n   * @returns {string} Formatted clock hour notation\n   */\n  static formatDetachment(segments) {\n    if (!segments || segments.length === 0) {\n      return \"None\";\n    }\n    if (segments.length >= 55) {\n      return \"1-12 o'clock\";\n    }\n\n    // Get all affected hours\n    const hours = new Set();\n    for (let hour = 1; hour <= 12; hour++) {\n      if (this.segmentsTouchHour(segments, hour)) {\n        hours.add(hour);\n      }\n    }\n\n    // Special handling for hours 3, 6, and 9\n    if (segments.some(s => s >= 10 && s <= 14 || s >= 20 && s <= 24)) {\n      hours.add(3);\n    }\n    if (segments.some(s => s >= 40 && s <= 44 || s >= 50 && s <= 54)) {\n      hours.add(9);\n    }\n    if (hours.has(5) || hours.has(7)) {\n      hours.add(6);\n    }\n\n    // Build ranges\n    const ranges = this.buildRanges(hours);\n\n    // Format output\n    return ranges.map(range => `${range.start}-${range.end}`).join('; ') + \" o'clock\";\n  }\n}\nClockHourNotation.SEGMENTS_PER_HOUR = 5;\nClockHourNotation.TOTAL_SEGMENTS = 60;\nexport { ClockHourNotation };\n\n// Test cases\nif (typeof describe !== 'undefined') {\n  describe('ClockHourNotation', () => {\n    const testCases = [{\n      name: 'Midnight crossing with 11 and 1',\n      segments: [50, 51, 52, 0, 1, 2],\n      expected: '11-1 o\\'clock'\n    }, {\n      name: 'Midnight crossing explicit 12',\n      segments: [50, 51, 52, 55, 56, 57, 0, 1, 2],\n      expected: '11-1 o\\'clock'\n    }, {\n      name: 'Empty segments',\n      segments: [],\n      expected: 'None'\n    }, {\n      name: 'Total detachment',\n      segments: Array.from({\n        length: 58\n      }, (_, i) => i),\n      expected: '1-12 o\\'clock'\n    }, {\n      name: 'Single hour',\n      segments: [0, 1, 2, 3, 4],\n      expected: '12-12 o\\'clock'\n    }, {\n      name: 'Midnight crossing simple',\n      segments: [53, 54, 55, 56, 57, 58, 59, 0, 1, 2],\n      expected: '11-1 o\\'clock'\n    }, {\n      name: 'Multiple ranges',\n      segments: [25, 26, 27, 28, 29, 30, 40, 41, 42],\n      expected: '6-6; 9-9 o\\'clock'\n    }, {\n      name: 'Hour 6 inclusion from 5',\n      segments: [20, 21, 22, 23, 24, 25],\n      expected: '5-6 o\\'clock'\n    }, {\n      name: 'Hour 6 inclusion from 7',\n      segments: [30, 31, 32, 33, 34],\n      expected: '6-7 o\\'clock'\n    }, {\n      name: 'Hour 3 inclusion from above',\n      segments: [10, 11, 12, 13, 14],\n      expected: '3-3 o\\'clock'\n    }, {\n      name: 'Hour 9 inclusion from above',\n      segments: [40, 41, 42, 43, 44],\n      expected: '9-9 o\\'clock'\n    }, {\n      name: 'Complex midnight crossing with multiple ranges',\n      segments: [...Array.from({\n        length: 5\n      }, (_, i) => i + 50),\n      // Hour 11\n      ...Array.from({\n        length: 5\n      }, (_, i) => i + 55),\n      // Hour 12\n      ...Array.from({\n        length: 5\n      }, (_, i) => i),\n      // Hour 1\n      ...Array.from({\n        length: 5\n      }, (_, i) => i + 25) // Hour 6\n      ],\n      expected: '11-1; 6-6 o\\'clock'\n    }, {\n      name: 'Special case from screenshot',\n      segments: [...Array.from({\n        length: 15\n      }, (_, i) => i + 40),\n      // Hours 9-11\n      ...Array.from({\n        length: 25\n      }, (_, i) => i + 10) // Hours 3-7\n      ],\n      expected: '9-12; 3-8 o\\'clock'\n    }];\n    testCases.forEach(({\n      name,\n      segments,\n      expected\n    }) => {\n      test(name, () => {\n        expect(ClockHourNotation.formatDetachment(segments)).toBe(expected);\n      });\n    });\n  });\n}","map":{"version":3,"names":["ClockHourNotation","segmentsTouchHour","segments","hour","hourRanges","some","s","start","end","buildRanges","hours","hourList","Array","from","has","hasMidnightCrossing","add","sort","a","b","includes","order","ranges","currentRange","i","length","prevHour","isConsecutive","push","formatDetachment","Set","map","range","join","SEGMENTS_PER_HOUR","TOTAL_SEGMENTS","describe","testCases","name","expected","_","forEach","test","expect","toBe"],"sources":["/Users/rose/Code/RCRD/src/components/clock/utils/clockHourNotation.js"],"sourcesContent":["class ClockHourNotation {\n    static SEGMENTS_PER_HOUR = 5;\n    static TOTAL_SEGMENTS = 60;\n\n    /**\n     * Check if any segments touch a given hour\n     * @param {number[]} segments - Array of segment numbers\n     * @param {number} hour - Clock hour to check\n     * @returns {boolean}\n     */\n    static segmentsTouchHour(segments, hour) {\n        // Define segment ranges for each hour\n        const hourRanges = {\n            1: [0, 4],      // Hour 1: 0-4\n            2: [5, 9],      // Hour 2: 5-9\n            3: [10, 14],    // Hour 3: 10-14\n            4: [15, 19],    // Hour 4: 15-19\n            5: [20, 24],    // Hour 5: 20-24\n            6: [25, 29],    // Hour 6: 25-29\n            7: [30, 34],    // Hour 7: 30-34\n            8: [35, 39],    // Hour 8: 35-39\n            9: [40, 44],    // Hour 9: 40-44\n            10: [45, 49],   // Hour 10: 45-49\n            11: [50, 54],   // Hour 11: 50-54\n            12: [55, 59]    // Hour 12: 55-59\n        };\n\n        if (hour === 12) {\n            return segments.some(s => s >= 55 || s <= 4);\n        }\n\n        const [start, end] = hourRanges[hour];\n        return segments.some(s => s >= start && s <= end);\n    }\n\n    /**\n     * Build ranges from hours with special midnight handling\n     * @param {Set<number>} hours \n     * @returns {Array<{start: number, end: number}>}\n     */\n    static buildRanges(hours) {\n        const hourList = Array.from(hours);\n        \n        // First, check for midnight crossing pattern\n        if (hours.has(11) || hours.has(12) || hours.has(1)) {\n            const hasMidnightCrossing = \n                (hours.has(11) && hours.has(1)) || \n                (hours.has(11) && hours.has(12)) ||\n                (hours.has(12) && hours.has(1));\n\n            if (hasMidnightCrossing) {\n                // Force inclusion of all midnight hours if any are present\n                if (hours.has(11) || hours.has(1)) {\n                    hours.add(11);\n                    hours.add(12);\n                    hours.add(1);\n                }\n\n                // Sort with midnight crossing logic\n                hourList.sort((a, b) => {\n                    // Special sorting for midnight hours\n                    if ([11, 12, 1].includes(a) && [11, 12, 1].includes(b)) {\n                        const order = { 11: 1, 12: 2, 1: 3 };\n                        return order[a] - order[b];\n                    }\n                    // Put midnight crossing range first\n                    if ([11, 12, 1].includes(a)) return -1;\n                    if ([11, 12, 1].includes(b)) return 1;\n                    return a - b;\n                });\n            }\n        } else {\n            // Simple numerical sort for non-midnight crossing ranges\n            hourList.sort((a, b) => a - b);\n        }\n\n        // Build ranges\n        const ranges = [];\n        let currentRange = { start: hourList[0], end: hourList[0] };\n\n        for (let i = 1; i < hourList.length; i++) {\n            const hour = hourList[i];\n            const prevHour = currentRange.end;\n            \n            const isConsecutive = \n                hour === prevHour + 1 || \n                (prevHour === 12 && hour === 1) ||\n                (prevHour === 11 && hour === 12);\n\n            if (isConsecutive) {\n                currentRange.end = hour;\n            } else {\n                ranges.push(currentRange);\n                currentRange = { start: hour, end: hour };\n            }\n        }\n        ranges.push(currentRange);\n\n        return ranges;\n    }\n\n    /**\n     * Format clock hour notation for retinal detachment\n     * @param {number[]} segments - Array of affected segments\n     * @returns {string} Formatted clock hour notation\n     */\n    static formatDetachment(segments) {\n        if (!segments || segments.length === 0) {\n            return \"None\";\n        }\n\n        if (segments.length >= 55) {\n            return \"1-12 o'clock\";\n        }\n\n        // Get all affected hours\n        const hours = new Set();\n        for (let hour = 1; hour <= 12; hour++) {\n            if (this.segmentsTouchHour(segments, hour)) {\n                hours.add(hour);\n            }\n        }\n\n        // Special handling for hours 3, 6, and 9\n        if (segments.some(s => (s >= 10 && s <= 14) || (s >= 20 && s <= 24))) {\n            hours.add(3);\n        }\n        if (segments.some(s => (s >= 40 && s <= 44) || (s >= 50 && s <= 54))) {\n            hours.add(9);\n        }\n        if (hours.has(5) || hours.has(7)) {\n            hours.add(6);\n        }\n\n        // Build ranges\n        const ranges = this.buildRanges(hours);\n\n        // Format output\n        return ranges\n            .map(range => `${range.start}-${range.end}`)\n            .join('; ') + \" o'clock\";\n    }\n}\n\nexport { ClockHourNotation };\n\n// Test cases\nif (typeof describe !== 'undefined') {\n    describe('ClockHourNotation', () => {\n        const testCases = [\n            {\n                name: 'Midnight crossing with 11 and 1',\n                segments: [50, 51, 52, 0, 1, 2],\n                expected: '11-1 o\\'clock'\n            },\n            {\n                name: 'Midnight crossing explicit 12',\n                segments: [50, 51, 52, 55, 56, 57, 0, 1, 2],\n                expected: '11-1 o\\'clock'\n            },\n            {\n                name: 'Empty segments',\n                segments: [],\n                expected: 'None'\n            },\n            {\n                name: 'Total detachment',\n                segments: Array.from({ length: 58 }, (_, i) => i),\n                expected: '1-12 o\\'clock'\n            },\n            {\n                name: 'Single hour',\n                segments: [0, 1, 2, 3, 4],\n                expected: '12-12 o\\'clock'\n            },\n            {\n                name: 'Midnight crossing simple',\n                segments: [53, 54, 55, 56, 57, 58, 59, 0, 1, 2],\n                expected: '11-1 o\\'clock'\n            },\n            {\n                name: 'Multiple ranges',\n                segments: [25, 26, 27, 28, 29, 30, 40, 41, 42],\n                expected: '6-6; 9-9 o\\'clock'\n            },\n            {\n                name: 'Hour 6 inclusion from 5',\n                segments: [20, 21, 22, 23, 24, 25],\n                expected: '5-6 o\\'clock'\n            },\n            {\n                name: 'Hour 6 inclusion from 7',\n                segments: [30, 31, 32, 33, 34],\n                expected: '6-7 o\\'clock'\n            },\n            {\n                name: 'Hour 3 inclusion from above',\n                segments: [10, 11, 12, 13, 14],\n                expected: '3-3 o\\'clock'\n            },\n            {\n                name: 'Hour 9 inclusion from above',\n                segments: [40, 41, 42, 43, 44],\n                expected: '9-9 o\\'clock'\n            },\n            {\n                name: 'Complex midnight crossing with multiple ranges',\n                segments: [\n                    ...Array.from({ length: 5 }, (_, i) => i + 50), // Hour 11\n                    ...Array.from({ length: 5 }, (_, i) => i + 55), // Hour 12\n                    ...Array.from({ length: 5 }, (_, i) => i),      // Hour 1\n                    ...Array.from({ length: 5 }, (_, i) => i + 25), // Hour 6\n                ],\n                expected: '11-1; 6-6 o\\'clock'\n            },\n            {\n                name: 'Special case from screenshot',\n                segments: [\n                    ...Array.from({ length: 15 }, (_, i) => i + 40), // Hours 9-11\n                    ...Array.from({ length: 25 }, (_, i) => i + 10)  // Hours 3-7\n                ],\n                expected: '9-12; 3-8 o\\'clock'\n            }\n        ];\n\n        testCases.forEach(({ name, segments, expected }) => {\n            test(name, () => {\n                expect(ClockHourNotation.formatDetachment(segments)).toBe(expected);\n            });\n        });\n    });\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}