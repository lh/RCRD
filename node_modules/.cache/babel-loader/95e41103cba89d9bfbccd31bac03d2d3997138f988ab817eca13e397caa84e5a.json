{"ast":null,"code":"// Core function for detecting if segments are adjacent\nconst areSegmentsAdjacent = (seg1, seg2) => {\n  // Normal adjacency\n  if (Math.abs(seg1 - seg2) === 1) return true;\n\n  // Wraparound adjacency\n  if (seg1 === 59 && seg2 === 0) return true;\n  if (seg1 === 0 && seg2 === 59) return true;\n  return false;\n};\n\n// Main range detection function\nexport const getSegmentRanges = segments => {\n  if (segments.length === 0) return [];\n\n  // Start with single-segment ranges\n  let numbers = [...segments];\n  let ranges = [{\n    start: numbers[0],\n    length: 1\n  }];\n  numbers.splice(0, 1);\n\n  // Keep trying to grow ranges until we can't\n  let madeChange;\n  do {\n    madeChange = false;\n\n    // For each range\n    for (let rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n      const range = ranges[rangeIndex];\n      const rangeStart = range.start;\n      const rangeEnd = (range.start + range.length - 1) % 60;\n\n      // Look at all remaining numbers\n      for (let numIndex = numbers.length - 1; numIndex >= 0; numIndex--) {\n        const num = numbers[numIndex];\n\n        // If number can extend range at either end\n        if (areSegmentsAdjacent(rangeStart - 1, num) || areSegmentsAdjacent(rangeEnd, num)) {\n          // Add to range\n          range.length++;\n          // Remove from numbers\n          numbers.splice(numIndex, 1);\n          madeChange = true;\n        }\n      }\n    }\n  } while (madeChange && numbers.length > 0);\n\n  // If any numbers left, recursively process them\n  if (numbers.length > 0) {\n    const remainingRanges = getSegmentRanges(numbers);\n    ranges = ranges.concat(remainingRanges);\n  }\n  return ranges;\n};\n\n// Define tests only if this file is executed directly\n// Run tests only if this file is executed directly\nif (import.meta.url === new URL(import.meta.url).href) {\n  // Test suite\n  function runSegmentRangeTests() {\n    const testCases = [{\n      name: \"Multiple wraparounds\",\n      input: [58, 59, 0, 1, 30, 31, 45, 46],\n      expected: [{\n        start: 58,\n        length: 4\n      }, {\n        start: 30,\n        length: 2\n      }, {\n        start: 45,\n        length: 2\n      }]\n    }, {\n      name: \"Single wraparound\",\n      input: [58, 59, 0, 1],\n      expected: [{\n        start: 58,\n        length: 4\n      }]\n    }, {\n      name: \"Two separate ranges with one wrapping\",\n      input: [58, 59, 0, 1, 30, 31, 32],\n      expected: [{\n        start: 58,\n        length: 4\n      }, {\n        start: 30,\n        length: 3\n      }]\n    }, {\n      name: \"Regular continuous range\",\n      input: [5, 6, 7, 8],\n      expected: [{\n        start: 5,\n        length: 4\n      }]\n    }, {\n      name: \"Empty input\",\n      input: [],\n      expected: []\n    }, {\n      name: \"Single segment\",\n      input: [5],\n      expected: [{\n        start: 5,\n        length: 1\n      }]\n    }];\n\n    // Run tests and collect results\n    const results = testCases.map(testCase => {\n      const result = getSegmentRanges(testCase.input);\n      const resultStr = JSON.stringify(result);\n      const expectedStr = JSON.stringify(testCase.expected);\n      const passed = resultStr === expectedStr;\n      return {\n        name: testCase.name,\n        input: testCase.input,\n        expected: testCase.expected,\n        actual: result,\n        passed: passed\n      };\n    });\n\n    // Return results rather than logging them\n    return results;\n  }\n\n  // Example of how to verify test results:\n  const results = runSegmentRangeTests();\n  results.forEach(result => {\n    console.log(`\\nTest: ${result.name}`);\n    console.log(`Input: [${result.input.join(', ')}]`);\n    console.log('Expected:', JSON.stringify(result.expected));\n    console.log('Actual:', JSON.stringify(result.actual));\n    console.log(`Result: ${result.passed ? 'PASS' : 'FAIL'}`);\n  });\n}","map":{"version":3,"names":["areSegmentsAdjacent","seg1","seg2","Math","abs","getSegmentRanges","segments","length","numbers","ranges","start","splice","madeChange","rangeIndex","range","rangeStart","rangeEnd","numIndex","num","remainingRanges","concat","import","meta","url","URL","href","runSegmentRangeTests","testCases","name","input","expected","results","map","testCase","result","resultStr","JSON","stringify","expectedStr","passed","actual","forEach","console","log","join"],"sources":["/Users/rose/Code/RCRD/src/components/clock/utils/getSegmentRanges.js"],"sourcesContent":["// Core function for detecting if segments are adjacent\nconst areSegmentsAdjacent = (seg1, seg2) => {\n    // Normal adjacency\n    if (Math.abs(seg1 - seg2) === 1) return true;\n\n    // Wraparound adjacency\n    if (seg1 === 59 && seg2 === 0) return true;\n    if (seg1 === 0 && seg2 === 59) return true;\n\n    return false;\n}\n\n// Main range detection function\nexport const getSegmentRanges = (segments) => {\n    if (segments.length === 0) return [];\n\n    // Start with single-segment ranges\n    let numbers = [...segments];\n    let ranges = [{ start: numbers[0], length: 1 }];\n    numbers.splice(0, 1);\n\n    // Keep trying to grow ranges until we can't\n    let madeChange;\n    do {\n        madeChange = false;\n\n        // For each range\n        for (let rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n            const range = ranges[rangeIndex];\n            const rangeStart = range.start;\n            const rangeEnd = (range.start + range.length - 1) % 60;\n\n            // Look at all remaining numbers\n            for (let numIndex = numbers.length - 1; numIndex >= 0; numIndex--) {\n                const num = numbers[numIndex];\n\n                // If number can extend range at either end\n                if (areSegmentsAdjacent(rangeStart - 1, num) ||\n                    areSegmentsAdjacent(rangeEnd, num)) {\n                    // Add to range\n                    range.length++;\n                    // Remove from numbers\n                    numbers.splice(numIndex, 1);\n                    madeChange = true;\n                }\n            }\n        }\n    } while (madeChange && numbers.length > 0);\n\n    // If any numbers left, recursively process them\n    if (numbers.length > 0) {\n        const remainingRanges = getSegmentRanges(numbers);\n        ranges = ranges.concat(remainingRanges);\n    }\n\n    return ranges;\n}\n\n\n\n// Define tests only if this file is executed directly\n// Run tests only if this file is executed directly\nif (import.meta.url === new URL(import.meta.url).href) {\n   \n    // Test suite\n    function runSegmentRangeTests() {\n        const testCases = [\n            {\n                name: \"Multiple wraparounds\",\n                input: [58, 59, 0, 1, 30, 31, 45, 46],\n                expected: [\n                    { start: 58, length: 4 },\n                    { start: 30, length: 2 },\n                    { start: 45, length: 2 }\n                ]\n            },\n            {\n                name: \"Single wraparound\",\n                input: [58, 59, 0, 1],\n                expected: [\n                    { start: 58, length: 4 }\n                ]\n            },\n            {\n                name: \"Two separate ranges with one wrapping\",\n                input: [58, 59, 0, 1, 30, 31, 32],\n                expected: [\n                    { start: 58, length: 4 },\n                    { start: 30, length: 3 }\n                ]\n            },\n            {\n                name: \"Regular continuous range\",\n                input: [5, 6, 7, 8],\n                expected: [\n                    { start: 5, length: 4 }\n                ]\n            },\n            {\n                name: \"Empty input\",\n                input: [],\n                expected: []\n            },\n            {\n                name: \"Single segment\",\n                input: [5],\n                expected: [\n                    { start: 5, length: 1 }\n                ]\n            }\n        ];\n\n        // Run tests and collect results\n        const results = testCases.map(testCase => {\n            const result = getSegmentRanges(testCase.input);\n            const resultStr = JSON.stringify(result);\n            const expectedStr = JSON.stringify(testCase.expected);\n            const passed = resultStr === expectedStr;\n\n            return {\n                name: testCase.name,\n                input: testCase.input,\n                expected: testCase.expected,\n                actual: result,\n                passed: passed\n            };\n        });\n\n        // Return results rather than logging them\n        return results;\n    }\n\n    // Example of how to verify test results:\n    const results = runSegmentRangeTests();\n    results.forEach(result => {\n        console.log(`\\nTest: ${result.name}`);\n        console.log(`Input: [${result.input.join(', ')}]`);\n        console.log('Expected:', JSON.stringify(result.expected));\n        console.log('Actual:', JSON.stringify(result.actual));\n        console.log(`Result: ${result.passed ? 'PASS' : 'FAIL'}`);\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}