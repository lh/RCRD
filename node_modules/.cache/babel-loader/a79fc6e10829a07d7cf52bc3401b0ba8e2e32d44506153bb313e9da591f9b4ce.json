{"ast":null,"code":"// Private helper function for detecting if segments are adjacent\nconst areSegmentsAdjacent = (seg1, seg2) => {\n  // Normal adjacency\n  if (Math.abs(seg1 - seg2) === 1) return true;\n\n  // Wraparound adjacency\n  if (seg1 === 59 && seg2 === 0) return true;\n  if (seg1 === 0 && seg2 === 59) return true;\n  return false;\n};\n\n/**\n * Groups consecutive segments into ranges, handling wraparound at 59/0\n * @param {number[]} segments - Array of segment numbers (0-59)\n * @returns {Array<{start: number, length: number}>} Array of range objects\n */\nexport const getSegmentRanges = segments => {\n  if (segments.length === 0) return [];\n\n  // Start with single-segment ranges\n  let numbers = [...segments];\n  let ranges = [{\n    start: numbers[0],\n    length: 1\n  }];\n  numbers.splice(0, 1);\n\n  // Keep trying to grow ranges until we can't\n  let madeChange;\n  do {\n    madeChange = false;\n\n    // For each range\n    for (let rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n      const range = ranges[rangeIndex];\n      const rangeStart = range.start;\n      const rangeEnd = (range.start + range.length - 1) % 60;\n\n      // Look at all remaining numbers\n      for (let numIndex = numbers.length - 1; numIndex >= 0; numIndex--) {\n        const num = numbers[numIndex];\n\n        // If number can extend range at either end\n        if (areSegmentsAdjacent(rangeStart - 1, num) || areSegmentsAdjacent(rangeEnd, num)) {\n          // Add to range\n          range.length++;\n          // Remove from numbers\n          numbers.splice(numIndex, 1);\n          madeChange = true;\n        }\n      }\n    }\n  } while (madeChange && numbers.length > 0);\n\n  // If any numbers left, recursively process them\n  if (numbers.length > 0) {\n    const remainingRanges = getSegmentRanges(numbers);\n    ranges = ranges.concat(remainingRanges);\n  }\n  return ranges;\n};\n\n// // Run tests only if this file is executed directly\n// if (import.meta.url === import.meta.resolve('./getSegmentRanges.js')) {\n//     const runSegmentRangeTests = () => {\n//         const testCases = [\n//             {\n//                 name: \"Multiple wraparounds\",\n//                 input: [58, 59, 0, 1, 30, 31, 45, 46],\n//                 expected: [\n//                     { start: 58, length: 4 },\n//                     { start: 30, length: 2 },\n//                     { start: 45, length: 2 }\n//                 ]\n//             },\n//             {\n//                 name: \"Single wraparound\",\n//                 input: [58, 59, 0, 1],\n//                 expected: [\n//                     { start: 58, length: 4 }\n//                 ]\n//             },\n//             {\n//                 name: \"Two separate ranges with one wrapping\",\n//                 input: [58, 59, 0, 1, 30, 31, 32],\n//                 expected: [\n//                     { start: 58, length: 4 },\n//                     { start: 30, length: 3 }\n//                 ]\n//             },\n//             {\n//                 name: \"Regular continuous range\",\n//                 input: [5, 6, 7, 8],\n//                 expected: [\n//                     { start: 5, length: 4 }\n//                 ]\n//             },\n//             {\n//                 name: \"Empty input\",\n//                 input: [],\n//                 expected: []\n//             },\n//             {\n//                 name: \"Single segment\",\n//                 input: [5],\n//                 expected: [\n//                     { start: 5, length: 1 }\n//                 ]\n//             }\n//         ];\n\n//         // Run tests and collect results\n//         const results = testCases.map(testCase => {\n//             const result = getSegmentRanges(testCase.input);\n//             const resultStr = JSON.stringify(result);\n//             const expectedStr = JSON.stringify(testCase.expected);\n//             const passed = resultStr === expectedStr;\n\n//             return {\n//                 name: testCase.name,\n//                 input: testCase.input,\n//                 expected: testCase.expected,\n//                 actual: result,\n//                 passed: passed\n//             };\n//         });\n\n//         // Print results\n//         results.forEach(result => {\n//             console.log(`\\nTest: ${result.name}`);\n//             console.log(`Input: [${result.input.join(', ')}]`);\n//             console.log('Expected:', JSON.stringify(result.expected));\n//             console.log('Actual:', JSON.stringify(result.actual));\n//             console.log(`Result: ${result.passed ? 'PASS' : 'FAIL'}`);\n//         });\n\n//         // Return overall test status\n//         return results.every(r => r.passed);\n//     };\n\n//     // Run the tests\n//     const testsPassed = runSegmentRangeTests();\n//     console.log(`\\nAll tests ${testsPassed ? 'PASSED' : 'FAILED'}`);\n// }","map":{"version":3,"names":["areSegmentsAdjacent","seg1","seg2","Math","abs","getSegmentRanges","segments","length","numbers","ranges","start","splice","madeChange","rangeIndex","range","rangeStart","rangeEnd","numIndex","num","remainingRanges","concat"],"sources":["/Users/rose/Code/RCRD/src/components/clock/utils/getSegmentRanges.js"],"sourcesContent":["// Private helper function for detecting if segments are adjacent\nconst areSegmentsAdjacent = (seg1, seg2) => {\n    // Normal adjacency\n    if (Math.abs(seg1 - seg2) === 1) return true;\n\n    // Wraparound adjacency\n    if (seg1 === 59 && seg2 === 0) return true;\n    if (seg1 === 0 && seg2 === 59) return true;\n\n    return false;\n};\n\n/**\n * Groups consecutive segments into ranges, handling wraparound at 59/0\n * @param {number[]} segments - Array of segment numbers (0-59)\n * @returns {Array<{start: number, length: number}>} Array of range objects\n */\nexport const getSegmentRanges = (segments) => {\n    if (segments.length === 0) return [];\n\n    // Start with single-segment ranges\n    let numbers = [...segments];\n    let ranges = [{ start: numbers[0], length: 1 }];\n    numbers.splice(0, 1);\n\n    // Keep trying to grow ranges until we can't\n    let madeChange;\n    do {\n        madeChange = false;\n\n        // For each range\n        for (let rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n            const range = ranges[rangeIndex];\n            const rangeStart = range.start;\n            const rangeEnd = (range.start + range.length - 1) % 60;\n\n            // Look at all remaining numbers\n            for (let numIndex = numbers.length - 1; numIndex >= 0; numIndex--) {\n                const num = numbers[numIndex];\n\n                // If number can extend range at either end\n                if (areSegmentsAdjacent(rangeStart - 1, num) ||\n                    areSegmentsAdjacent(rangeEnd, num)) {\n                    // Add to range\n                    range.length++;\n                    // Remove from numbers\n                    numbers.splice(numIndex, 1);\n                    madeChange = true;\n                }\n            }\n        }\n    } while (madeChange && numbers.length > 0);\n\n    // If any numbers left, recursively process them\n    if (numbers.length > 0) {\n        const remainingRanges = getSegmentRanges(numbers);\n        ranges = ranges.concat(remainingRanges);\n    }\n\n    return ranges;\n};\n\n// // Run tests only if this file is executed directly\n// if (import.meta.url === import.meta.resolve('./getSegmentRanges.js')) {\n//     const runSegmentRangeTests = () => {\n//         const testCases = [\n//             {\n//                 name: \"Multiple wraparounds\",\n//                 input: [58, 59, 0, 1, 30, 31, 45, 46],\n//                 expected: [\n//                     { start: 58, length: 4 },\n//                     { start: 30, length: 2 },\n//                     { start: 45, length: 2 }\n//                 ]\n//             },\n//             {\n//                 name: \"Single wraparound\",\n//                 input: [58, 59, 0, 1],\n//                 expected: [\n//                     { start: 58, length: 4 }\n//                 ]\n//             },\n//             {\n//                 name: \"Two separate ranges with one wrapping\",\n//                 input: [58, 59, 0, 1, 30, 31, 32],\n//                 expected: [\n//                     { start: 58, length: 4 },\n//                     { start: 30, length: 3 }\n//                 ]\n//             },\n//             {\n//                 name: \"Regular continuous range\",\n//                 input: [5, 6, 7, 8],\n//                 expected: [\n//                     { start: 5, length: 4 }\n//                 ]\n//             },\n//             {\n//                 name: \"Empty input\",\n//                 input: [],\n//                 expected: []\n//             },\n//             {\n//                 name: \"Single segment\",\n//                 input: [5],\n//                 expected: [\n//                     { start: 5, length: 1 }\n//                 ]\n//             }\n//         ];\n\n//         // Run tests and collect results\n//         const results = testCases.map(testCase => {\n//             const result = getSegmentRanges(testCase.input);\n//             const resultStr = JSON.stringify(result);\n//             const expectedStr = JSON.stringify(testCase.expected);\n//             const passed = resultStr === expectedStr;\n\n//             return {\n//                 name: testCase.name,\n//                 input: testCase.input,\n//                 expected: testCase.expected,\n//                 actual: result,\n//                 passed: passed\n//             };\n//         });\n\n//         // Print results\n//         results.forEach(result => {\n//             console.log(`\\nTest: ${result.name}`);\n//             console.log(`Input: [${result.input.join(', ')}]`);\n//             console.log('Expected:', JSON.stringify(result.expected));\n//             console.log('Actual:', JSON.stringify(result.actual));\n//             console.log(`Result: ${result.passed ? 'PASS' : 'FAIL'}`);\n//         });\n\n//         // Return overall test status\n//         return results.every(r => r.passed);\n//     };\n\n//     // Run the tests\n//     const testsPassed = runSegmentRangeTests();\n//     console.log(`\\nAll tests ${testsPassed ? 'PASSED' : 'FAILED'}`);\n// }"],"mappings":"AAAA;AACA,MAAMA,mBAAmB,GAAGA,CAACC,IAAI,EAAEC,IAAI,KAAK;EACxC;EACA,IAAIC,IAAI,CAACC,GAAG,CAACH,IAAI,GAAGC,IAAI,CAAC,KAAK,CAAC,EAAE,OAAO,IAAI;;EAE5C;EACA,IAAID,IAAI,KAAK,EAAE,IAAIC,IAAI,KAAK,CAAC,EAAE,OAAO,IAAI;EAC1C,IAAID,IAAI,KAAK,CAAC,IAAIC,IAAI,KAAK,EAAE,EAAE,OAAO,IAAI;EAE1C,OAAO,KAAK;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,gBAAgB,GAAIC,QAAQ,IAAK;EAC1C,IAAIA,QAAQ,CAACC,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE;;EAEpC;EACA,IAAIC,OAAO,GAAG,CAAC,GAAGF,QAAQ,CAAC;EAC3B,IAAIG,MAAM,GAAG,CAAC;IAAEC,KAAK,EAAEF,OAAO,CAAC,CAAC,CAAC;IAAED,MAAM,EAAE;EAAE,CAAC,CAAC;EAC/CC,OAAO,CAACG,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;;EAEpB;EACA,IAAIC,UAAU;EACd,GAAG;IACCA,UAAU,GAAG,KAAK;;IAElB;IACA,KAAK,IAAIC,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGJ,MAAM,CAACF,MAAM,EAAEM,UAAU,EAAE,EAAE;MAC/D,MAAMC,KAAK,GAAGL,MAAM,CAACI,UAAU,CAAC;MAChC,MAAME,UAAU,GAAGD,KAAK,CAACJ,KAAK;MAC9B,MAAMM,QAAQ,GAAG,CAACF,KAAK,CAACJ,KAAK,GAAGI,KAAK,CAACP,MAAM,GAAG,CAAC,IAAI,EAAE;;MAEtD;MACA,KAAK,IAAIU,QAAQ,GAAGT,OAAO,CAACD,MAAM,GAAG,CAAC,EAAEU,QAAQ,IAAI,CAAC,EAAEA,QAAQ,EAAE,EAAE;QAC/D,MAAMC,GAAG,GAAGV,OAAO,CAACS,QAAQ,CAAC;;QAE7B;QACA,IAAIjB,mBAAmB,CAACe,UAAU,GAAG,CAAC,EAAEG,GAAG,CAAC,IACxClB,mBAAmB,CAACgB,QAAQ,EAAEE,GAAG,CAAC,EAAE;UACpC;UACAJ,KAAK,CAACP,MAAM,EAAE;UACd;UACAC,OAAO,CAACG,MAAM,CAACM,QAAQ,EAAE,CAAC,CAAC;UAC3BL,UAAU,GAAG,IAAI;QACrB;MACJ;IACJ;EACJ,CAAC,QAAQA,UAAU,IAAIJ,OAAO,CAACD,MAAM,GAAG,CAAC;;EAEzC;EACA,IAAIC,OAAO,CAACD,MAAM,GAAG,CAAC,EAAE;IACpB,MAAMY,eAAe,GAAGd,gBAAgB,CAACG,OAAO,CAAC;IACjDC,MAAM,GAAGA,MAAM,CAACW,MAAM,CAACD,eAAe,CAAC;EAC3C;EAEA,OAAOV,MAAM;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}