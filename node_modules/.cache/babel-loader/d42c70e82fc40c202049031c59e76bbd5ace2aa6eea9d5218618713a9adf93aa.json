{"ast":null,"code":"/**\n * Interpolates between non-adjacent segments to create continuous ranges\n * @param {number[]} segments - Array of segment numbers (0-59)\n * @returns {number[]} Array of segments including interpolated values\n */\nexport const interpolateSegments = segments => {\n  if (segments.length <= 1) return segments;\n\n  // Create a new array and sort the input segments\n  const sortedSegments = [...segments].sort((a, b) => a - b);\n  const result = [];\n\n  // Handle wraparound case first\n  if (sortedSegments[0] === 0 && sortedSegments[sortedSegments.length - 1] >= 55) {\n    // Move segments > 55 to the front of our processing queue\n    while (sortedSegments.length > 0 && sortedSegments[sortedSegments.length - 1] >= 55) {\n      const seg = sortedSegments.pop();\n      sortedSegments.unshift(seg);\n    }\n  }\n\n  // Process each pair of segments\n  for (let i = 0; i < sortedSegments.length - 1; i++) {\n    const current = sortedSegments[i];\n    const next = sortedSegments[i + 1];\n    result.push(current);\n\n    // Calculate the gap size (handling wraparound)\n    let gap = next - current;\n    if (gap < 0) gap += 60; // Wraparound case\n\n    // If segments are more than 1 unit but less than 7 units apart, interpolate\n    if (gap > 1 && gap <= 7) {\n      for (let j = 1; j < gap; j++) {\n        result.push((current + j) % 60);\n      }\n    }\n  }\n\n  // Add the last segment\n  result.push(sortedSegments[sortedSegments.length - 1]);\n  return result;\n};\n\n// // Run tests only if this file is executed directly\n// will need to import  files\n// import { getSegmentRanges } from './getSegmentRanges.js';\n// import { getClockHour } from './getClockHour.js';\n// import { formatDetachmentHours } from './formatDetachmentHours.js';\n//\n// if (import.meta.url === import.meta.resolve('./interpolateSegments.js')) {\n//     const testCases = [\n//         {\n//             name: 'Test 1',\n//             input: [58, 1, 2, 5, 10],\n//             expected: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 58],\n//             expectedFormatted: '12-2; 12 o\\'clock'\n//         },\n//         {\n//             name: 'Test 2',\n//             input: [0, 1, 2, 3, 4, 5],\n//             expected: [0, 1, 2, 3, 4, 5],\n//             expectedFormatted: '12-1 o\\'clock'\n//         },\n//         {\n//             name: 'Test 3',\n//             input: [10, 20, 30, 40, 50],\n//             expected: [10, 20, 30, 40, 50],\n//             expectedFormatted: '2; 4; 6; 8; 10 o\\'clock'\n//         },\n//         {\n//             name: 'Test 4',\n//             input: [55, 0, 5, 10, 15],\n//             expected: [55, 56, 57, 58, 59, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n//             expectedFormatted: '11-3 o\\'clock'\n//         }\n//     ];\n\n//     // Run tests\n//     const results = testCases.map(testCase => {\n//         const interpolated = interpolateSegments(testCase.input);\n//         const formatted = formatDetachmentHours(interpolated);\n//         const interpolatedMatch = JSON.stringify(interpolated) === JSON.stringify(testCase.expected);\n//         const formattedMatch = formatted === testCase.expectedFormatted;\n\n//         return {\n//             name: testCase.name,\n//             input: testCase.input,\n//             interpolatedResult: interpolated,\n//             interpolatedExpected: testCase.expected,\n//             interpolatedMatch,\n//             formattedResult: formatted,\n//             formattedExpected: testCase.expectedFormatted,\n//             formattedMatch,\n//             passed: interpolatedMatch && formattedMatch\n//         };\n//     });\n\n//     // Print results\n//     results.forEach(result => {\n//         console.log(`\\nTest: ${result.name}`);\n//         console.log(`Input: [${result.input.join(', ')}]`);\n//         console.log(`Interpolated Result: [${result.interpolatedResult.join(', ')}]`);\n//         console.log(`Interpolated Expected: [${result.interpolatedExpected.join(', ')}]`);\n//         console.log(`Formatted Result: ${result.formattedResult}`);\n//         console.log(`Formatted Expected: ${result.formattedExpected}`);\n//         console.log(`Result: ${result.passed ? 'PASS' : 'FAIL'}`);\n//     });\n\n//     // Print overall status\n//     const testsPassed = results.every(r => r.passed);\n//     console.log(`\\nAll tests ${testsPassed ? 'PASSED' : 'FAILED'}`);\n// }","map":{"version":3,"names":["interpolateSegments","segments","length","sortedSegments","sort","a","b","result","seg","pop","unshift","i","current","next","push","gap","j"],"sources":["/Users/rose/Code/RCRD/src/components/clock/utils/interpolateSegments.js"],"sourcesContent":["\n/**\n * Interpolates between non-adjacent segments to create continuous ranges\n * @param {number[]} segments - Array of segment numbers (0-59)\n * @returns {number[]} Array of segments including interpolated values\n */\nexport const interpolateSegments = (segments) => {\n    if (segments.length <= 1) return segments;\n    \n    // Create a new array and sort the input segments\n    const sortedSegments = [...segments].sort((a, b) => a - b);\n    const result = [];\n    \n    // Handle wraparound case first\n    if (sortedSegments[0] === 0 && sortedSegments[sortedSegments.length - 1] >= 55) {\n        // Move segments > 55 to the front of our processing queue\n        while (sortedSegments.length > 0 && sortedSegments[sortedSegments.length - 1] >= 55) {\n            const seg = sortedSegments.pop();\n            sortedSegments.unshift(seg);\n        }\n    }\n    \n    // Process each pair of segments\n    for (let i = 0; i < sortedSegments.length - 1; i++) {\n        const current = sortedSegments[i];\n        const next = sortedSegments[i + 1];\n        result.push(current);\n        \n        // Calculate the gap size (handling wraparound)\n        let gap = next - current;\n        if (gap < 0) gap += 60; // Wraparound case\n        \n        // If segments are more than 1 unit but less than 7 units apart, interpolate\n        if (gap > 1 && gap <= 7) {\n            for (let j = 1; j < gap; j++) {\n                result.push((current + j) % 60);\n            }\n        }\n    }\n    \n    // Add the last segment\n    result.push(sortedSegments[sortedSegments.length - 1]);\n    \n    return result;\n};\n\n// // Run tests only if this file is executed directly\n// will need to import  files\n// import { getSegmentRanges } from './getSegmentRanges.js';\n// import { getClockHour } from './getClockHour.js';\n// import { formatDetachmentHours } from './formatDetachmentHours.js';\n//\n// if (import.meta.url === import.meta.resolve('./interpolateSegments.js')) {\n//     const testCases = [\n//         {\n//             name: 'Test 1',\n//             input: [58, 1, 2, 5, 10],\n//             expected: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 58],\n//             expectedFormatted: '12-2; 12 o\\'clock'\n//         },\n//         {\n//             name: 'Test 2',\n//             input: [0, 1, 2, 3, 4, 5],\n//             expected: [0, 1, 2, 3, 4, 5],\n//             expectedFormatted: '12-1 o\\'clock'\n//         },\n//         {\n//             name: 'Test 3',\n//             input: [10, 20, 30, 40, 50],\n//             expected: [10, 20, 30, 40, 50],\n//             expectedFormatted: '2; 4; 6; 8; 10 o\\'clock'\n//         },\n//         {\n//             name: 'Test 4',\n//             input: [55, 0, 5, 10, 15],\n//             expected: [55, 56, 57, 58, 59, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n//             expectedFormatted: '11-3 o\\'clock'\n//         }\n//     ];\n\n//     // Run tests\n//     const results = testCases.map(testCase => {\n//         const interpolated = interpolateSegments(testCase.input);\n//         const formatted = formatDetachmentHours(interpolated);\n//         const interpolatedMatch = JSON.stringify(interpolated) === JSON.stringify(testCase.expected);\n//         const formattedMatch = formatted === testCase.expectedFormatted;\n\n//         return {\n//             name: testCase.name,\n//             input: testCase.input,\n//             interpolatedResult: interpolated,\n//             interpolatedExpected: testCase.expected,\n//             interpolatedMatch,\n//             formattedResult: formatted,\n//             formattedExpected: testCase.expectedFormatted,\n//             formattedMatch,\n//             passed: interpolatedMatch && formattedMatch\n//         };\n//     });\n\n//     // Print results\n//     results.forEach(result => {\n//         console.log(`\\nTest: ${result.name}`);\n//         console.log(`Input: [${result.input.join(', ')}]`);\n//         console.log(`Interpolated Result: [${result.interpolatedResult.join(', ')}]`);\n//         console.log(`Interpolated Expected: [${result.interpolatedExpected.join(', ')}]`);\n//         console.log(`Formatted Result: ${result.formattedResult}`);\n//         console.log(`Formatted Expected: ${result.formattedExpected}`);\n//         console.log(`Result: ${result.passed ? 'PASS' : 'FAIL'}`);\n//     });\n\n//     // Print overall status\n//     const testsPassed = results.every(r => r.passed);\n//     console.log(`\\nAll tests ${testsPassed ? 'PASSED' : 'FAILED'}`);\n// }"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,mBAAmB,GAAIC,QAAQ,IAAK;EAC7C,IAAIA,QAAQ,CAACC,MAAM,IAAI,CAAC,EAAE,OAAOD,QAAQ;;EAEzC;EACA,MAAME,cAAc,GAAG,CAAC,GAAGF,QAAQ,CAAC,CAACG,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC;EAC1D,MAAMC,MAAM,GAAG,EAAE;;EAEjB;EACA,IAAIJ,cAAc,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIA,cAAc,CAACA,cAAc,CAACD,MAAM,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;IAC5E;IACA,OAAOC,cAAc,CAACD,MAAM,GAAG,CAAC,IAAIC,cAAc,CAACA,cAAc,CAACD,MAAM,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;MACjF,MAAMM,GAAG,GAAGL,cAAc,CAACM,GAAG,CAAC,CAAC;MAChCN,cAAc,CAACO,OAAO,CAACF,GAAG,CAAC;IAC/B;EACJ;;EAEA;EACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,cAAc,CAACD,MAAM,GAAG,CAAC,EAAES,CAAC,EAAE,EAAE;IAChD,MAAMC,OAAO,GAAGT,cAAc,CAACQ,CAAC,CAAC;IACjC,MAAME,IAAI,GAAGV,cAAc,CAACQ,CAAC,GAAG,CAAC,CAAC;IAClCJ,MAAM,CAACO,IAAI,CAACF,OAAO,CAAC;;IAEpB;IACA,IAAIG,GAAG,GAAGF,IAAI,GAAGD,OAAO;IACxB,IAAIG,GAAG,GAAG,CAAC,EAAEA,GAAG,IAAI,EAAE,CAAC,CAAC;;IAExB;IACA,IAAIA,GAAG,GAAG,CAAC,IAAIA,GAAG,IAAI,CAAC,EAAE;MACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,EAAEC,CAAC,EAAE,EAAE;QAC1BT,MAAM,CAACO,IAAI,CAAC,CAACF,OAAO,GAAGI,CAAC,IAAI,EAAE,CAAC;MACnC;IACJ;EACJ;;EAEA;EACAT,MAAM,CAACO,IAAI,CAACX,cAAc,CAACA,cAAc,CAACD,MAAM,GAAG,CAAC,CAAC,CAAC;EAEtD,OAAOK,MAAM;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}